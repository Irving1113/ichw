## 概论作业2
**1. 用你的语言描述图灵为什么要证明停机问题, 其证明方法和数学原理是什么.**
- 图灵想要证明：能否找到一种普遍的算法，可用来判定一个任意形式的丢番图方程是否有整数解？于是他假想出了一个图灵机，来辅助这个问题的证明，将这个歌问题转化为了对停机问题的证明：对于任何程序和输入，能否判定其会停机。
- 他的证明方法是，先假定存在一个算法f，对于任何程序和输入，能判定其会停机。而后，他又设计了一个程序g：如果算法f判定其为真，则运算不停止，返回到假；如果不是，则输出真。当用g程序运算g时，机器不能判定其会停机。这与假设矛盾，因而证明了问题。
- 这种方法的数学原理是反证法。

**2. 你在向中学生做科普，请向他们解释二进制补码的原理.**
- 我们先给出补码的运算方法：对于正数，它的补码就是原码；对于负数，它的补码是它的反码再加一。补码的作用是使计算机把运算两个数的减法转化为运算一个正数和一个负数的加法。根据作用，正数的补码运算不难理解，现讨论负数的码。

  一块钟表有1-12共12个数字，如果想将两点调成三点，可以顺时针调快1小时，或逆时针调慢11小时。我们规定顺时针为正，逆时针为负，那么我们可以将调快1小时表示为1，调慢11小时表示为-11。由于两种操作最后产生的效果是一样的，所以我们可以称-11的补码为1。同时我们注意到，1+11=12。据此我们想象一个模型：有一个圆盘，上有00…00（n个0）-11…11（n个1），这个圆盘上共有（100…00）<sub>2</sub> 个数（n个0）。类比钟表，我们再看负数补码的运算：负数的原码与反码相加为一串全1的数，再加一即等于（100…00）<sub>2</sub>（n个0）。所以说，一个负数的原码与它的反码加一的效果是等同的。

  在上述调节钟表的两种方法中，实际上两种方法之间差了一周的时间，而这个时间不能体现在钟表上，因而被我们舍弃不计。类比钟表，我们同样可以得出在二进制补码的运算中舍弃溢出的高位的原因。
  
**3. 某基于 IEEE 754浮点数格式的 16 bit 浮点数表示, 有 8 个小数位, 请给出 ±0, ±1.0, 最大非规范化数, 最小非规范化数, 最小规范化浮点数, 最大规范化浮点数,
±∞, NaN 的二进制表示(表示形式请参照讲义).**

|Sign   |Exp    |Frac   |Value  |
|-------|-------|-------|-------|
|*      |0000 0000 |000 0000 |±0.0 |
|0      |0111 1111 |000 0000 |1.0 |
|1      |0111 1111 |000 0000 |-1.0 |
|0      |0000 0000 |111 1111 | (1−2<sup>−7</sup>)× 2<sup>−126</sup> 最大非规范化数 |
|1      |0000 0000 |111 1111 |-(1−2<sup>−7</sup>)× 2<sup>−126</sup>  最小非规范化数 |
|0      |1111 1110 |111 1111 | (2−2<sup>−7</sup>) × 2<sup>127</sup>)  最大规范化浮点数|
|1      |1111 1110 |111 1111 |-(2−2<sup>−7</sup>) × 2<sup>127</sup>)  最小规范化浮点数|
|*      |1111 1111 |000 0000 |±∞ |
|*      |1111 1111 |non zone |NaN |
